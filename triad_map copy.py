inverions = {
    'major':{ 
              '123':
              {'root':[('5th','-2'),('3rd','0'),('root','0')],
              '1st_inversion':[('root','0'),('5th','0'),('3d','+1')],
              '2nd_inversion':[('3rd','-1'),('root','0'),('5th','-1')]},
              '234':
              {'root':[('5th','-2'),('3rd','-1'),('root','0')],
              '1st_inversion':[('root','0'),('5th','-1'),('3d','+1')],
              '2nd_inversion':[('3rd','0'),('root','0'),('5th','0')]},
              '345':
              {'root':[('5th','-3'),('3rd','-1'),('root','0')],
              '1st_inversion':[('root','0'),('5th','0'),('3d','+2')],
              '2nd_inversion':[('3rd','-1'),('root','0'),('5th','0')]},
              '456':
              {'root':[('5th','-3'),('3rd','-1'),('root','0')],
              '1st_inversion':[('root','0'),('5th','0'),('3d','+2')],
              '2nd_inversion':[('3rd','-1'),('root','0'),('5th','0')]},
    },
    'monior':{ 
              '123':
              {'root':[('5th','-2'),('3rd','-1'),('root','0')],
              '1st_inversion':[('root','0'),('5th','0'),('3d','0')],
              '2nd_inversion':[('3rd','-2'),('root','0'),('5th','-1')]},
              '234':
              {'root':[('5th','-2'),('3rd','-2'),('root','0')],
              '1st_inversion':[('root','0'),('5th','-1'),('3d','0')],
              '2nd_inversion':[('3rd','-1'),('root','0'),('5th','0')]},
              '345':
              {'root':[('5th','-3'),('3rd','-2'),('root','0')],
              '1st_inversion':[('root','0'),('5th','0'),('3d','+1')],
              '2nd_inversion':[('3rd','-2'),('root','0'),('5th','0')]},
              '456':
              {'root':[('5th','-3'),('3rd','-2'),('root','0')],
              '1st_inversion':[('root','0'),('5th','0'),('3d','+1')],
              '2nd_inversion':[('3rd','-2'),('root','0'),('5th','0')]}
    },
    'augmented':{ 
              '123':
              {'root':[('5th','-1'),('3rd','0'),('root','0')],
              '1st_inversion':[('root','0'),('5th','+1'),('3d','+1')],
              '2nd_inversion':[('3rd','-1'),('root','0'),('5th','0')]},
              '234':
              {'root':[('5th','-1'),('3rd','-1'),('root','0')],
              '1st_inversion':[('root','0'),('5th','0'),('3d','+1')],
              '2nd_inversion':[('3rd','0'),('root','0'),('5th','+1')]},
              '345':
              {'root':[('5th','-2'),('3rd','-1'),('root','0')],
              '1st_inversion':[('root','0'),('5th','+1'),('3d','+2')],
              '2nd_inversion':[('3rd','-1'),('root','0'),('5th','+1')]},
              '456':
              {'root':[('5th','-2'),('3rd','-1'),('root','0')],
              '1st_inversion':[('root','0'),('5th','+1'),('3d','+2')],
              '2nd_inversion':[('3rd','-1'),('root','0'),('5th','+1')]}
    },
    'diminished':{ 
              '123':
              {'root':[('5th','-3'),('3rd','-1'),('root','0')],
              '1st_inversion':[('root','0'),('5th','-1'),('3d','0')],
              '2nd_inversion':[('3rd','-2'),('root','0'),('5th','-2')]},
              '234':
              {'root':[('5th','-3'),('3rd','-2'),('root','0')],
              '1st_inversion':[('root','0'),('5th','-2'),('3d','0')],
              '2nd_inversion':[('3rd','-1'),('root','0'),('5th','-1')]},
              '345':
              {'root':[('5th','-4'),('3rd','-2'),('root','0')],
              '1st_inversion':[('root','0'),('5th','-1'),('3d','+1')],
              '2nd_inversion':[('3rd','-2'),('root','0'),('5th','-1')]},
              '456':
              {'root':[('5th','-4'),('3rd','-2'),('root','0')],
              '1st_inversion':[('root','0'),('5th','-1'),('3d','+1')],
              '2nd_inversion':[('3rd','-2'),('root','0'),('5th','-1')]}
    },
    'sus2':{ 
              '123':
              {'root':[('5th','-2'),('3rd','-2'),('root','0')],
              '1st_inversion':[('root','0'),('5th','0'),('3d','-1')],
              '2nd_inversion':[('3rd','-3'),('root','0'),('5th','-1')]},
              '234':
              {'root':[('5th','-2'),('3rd','-3'),('root','0')],
              '1st_inversion':[('root','0'),('5th','-1'),('3d','-1')],
              '2nd_inversion':[('3rd','-2'),('root','0'),('5th','0')]},
              '345':
              {'root':[('5th','-3'),('3rd','-3'),('root','0')],
              '1st_inversion':[('root','0'),('5th','0'),('3d','0')],
              '2nd_inversion':[('3rd','-3'),('root','0'),('5th','0')]},
              '456':
              {'root':[('5th','-3'),('3rd','-3'),('root','0')],
              '1st_inversion':[('root','0'),('5th','0'),('3d','0')],
              '2nd_inversion':[('3rd','-3'),('root','0'),('5th','0')]}
    },
    'sus4':{ 
              '123':
              {'root':[('5th','-2'),('3rd','+1'),('root','0')],
              '1st_inversion':[('root','0'),('5th','0'),('3d','+2')],
              '2nd_inversion':[('3rd','0'),('root','0'),('5th','-1')]},
              '234':
              {'root':[('5th','-2'),('3rd','0'),('root','0')],
              '1st_inversion':[('root','0'),('5th','-1'),('3d','+2')],
              '2nd_inversion':[('3rd','+1'),('root','0'),('5th','0')]},
              '345':
              {'root':[('5th','-3'),('3rd','0'),('root','0')],
              '1st_inversion':[('root','0'),('5th','0'),('3d','+3')],
              '2nd_inversion':[('3rd','0'),('root','0'),('5th','0')]},
              '456':
              {'root':[('5th','-3'),('3rd','0'),('root','0')],
              '1st_inversion':[('root','0'),('5th','0'),('3d','+3')],
              '2nd_inversion':[('3rd','0'),('root','0'),('5th','0')]}
    }
}

chromatic_notes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"]
open_string_notes = [("E",4,3),("B",11,3),("G",7,3),("D",2,3),("A",9,2),("E",4,2)]
triadTypes = ["major","minor","diminished","augmented","sus2","sus4"]
stringSets = ["123",'234','345','456']

def get_key_from_value(d, target_value):
    for key, value in d.items():
        if value == target_value:
            return key
    return None  # Return None if the value is not found

fretboardNotes ={}
def generate_strings_notes_22frets():
    global chromatic_notes
    global open_string_notes
    fretboardNotes = {}
    for i in range(6):
        string = []
        startNote = open_string_notes[i][0]
        startNoteIdx = open_string_notes[i][1]
        startOctave = open_string_notes[i][2]
        k = startNoteIdx
        for j in range(23):
            if k%12 == 0:
                k = 0
                startOctave = startOctave + 1
            string.append((chromatic_notes[k],str(startOctave)))
            k = k + 1
        fretboardNotes["string"+str(i+1)] = string
    return fretboardNotes

strings_notes_22frets = generate_strings_notes_22frets()
#print(strings_notes_22frets)

def find_root_positions(triad_info):
    """Finds the positions of root notes in each inversion."""
    root_positions = {}
    
    for inversion, notes in triad_info.items():
        # Extract the root note position in each inversion
        for index, note_info in enumerate(notes):
            if note_info[0] == 'root':
                root_positions[inversion] = index+1  # Store string and position
                break  # Stop once we find the root note for this inversion
    
    return root_positions

def find_3rd_positions(triad_info):
    """Finds the positions of root notes in each inversion."""
    root_positions = {}
    
    for inversion, notes in triad_info.items():
        # Extract the root note position in each inversion
        for index, note_info in enumerate(notes):
            if note_info[0] == '3rd':
                root_positions[inversion] = index+1  # Store string and position
                break  # Stop once we find the root note for this inversion
    
    return root_positions

def find_5th_positions(triad_info):
    """Finds the positions of root notes in each inversion."""
    root_positions = {}
    
    for inversion, notes in triad_info.items():
        # Extract the root note position in each inversion
        for index, note_info in enumerate(notes):
            if note_info[0] == '5th':
                root_positions[inversion] = index+1  # Store string and position
                break  # Stop once we find the root note for this inversion
    
    return root_positions

def findANote(NoteList,snote):
    return [(index, item) for index, item in enumerate(NoteList) if item[0] == snote]

def runOnTriadType(triad,sroot):
    #print(triad)
    #print(inverions[triad])
    return runOnSringSets(inverions[triad],sroot)



def runOnSringSets(triadType,sroot):
    #print(triadType)
    noteDic = {}

    for i in range(len(stringSets)):
        noteDic[stringSets[i]] = []
        roots = {}
        #print("x~"*30)
        #print(stringSets[i], triadType[stringSets[i]])
        #print("x~"*30)
        
        st = [0,1,2]
        st = [x + i for x in st]
        #print(stringSets)
        roots[stringSets[i]] = []
        #finding the roots on the string sets    
        for j in range(len(st)):
            #print("string"+str(st[j]+1))
            curr_string = strings_notes_22frets["string"+str(st[j]+1)]
            #print(findANote(curr_string,"E"))
            roots[stringSets[i]].append((st[j]+1,findANote(curr_string,sroot)))
            #pass
            #print(strings_notes_22frets["string"+str(j+1)])
        #print("o~"*30)
        #print(roots)  
        #print("o~"*30)
        
        dic2 = {}
        for j,stw in enumerate(roots[stringSets[i]]):
            x1 = stw[0]
            dic2[j+1] = []
            for k1,k2 in enumerate(stw[1]):
                print(j+1,k2[0])
                dic2[j+1].append(k2[0])     
        
        print("roots in the strings set ------->>>>",dic2)
        print("<>"*40)
        # Loop over the keys
        print(st)
        strg = st[0]+1
        for key, value in dic2.items():
            strng = key
            print("start string ",strg)
            for offset in value:
                for inversion, notes_list in triadType[stringSets[i]].items():
                    for index, note in enumerate(notes_list):
                        if note[0] == "root":
                            if index+1 == key:
                                print(f"Inversion: contains root at position: {index}")
                                print(f"Inversion: {inversion} - root is in the set's {key} string  - string {strg+index} - offset {offset}")
                                loc_root = "string"+str(strg+index)
                                note_root = strings_notes_22frets[loc_root][offset]
                                print(f"{loc_root} Note: {note[0]}, Position: {offset} - {note_root}")
                                # Loop inside the list of tuples
                                rootPos = index
                                pos5th = (index+1)%3
                                pose3rd = (index+2)%3
                                print(rootPos,pos5th,pose3rd)
                                print(notes_list[(index+1)%3][0])
                                print(notes_list[(index+2)%3][0])
                                loc_5th = "string"+str(strg+(index+1)%3)
                                valid = 1
                                fretboard_position = int(offset)+int(notes_list[(index+1)%3][1])
                                if fretboard_position > -1 and fretboard_position < 23:
                                    note_5th = strings_notes_22frets[loc_5th][int(offset)+int(notes_list[(index+1)%3][1])]
                                    print(f"{loc_5th} Note: 5th, Position: {offset} - {note_5th}")
                                    valid = valid + 1

                                loc_3rd = "string"+str(strg+(index+2)%3)
                                fretboard_position = int(offset)+int(notes_list[(index+2)%3][1])
                                if fretboard_position > -1 and fretboard_position < 23:
                                    note_3rd = strings_notes_22frets[loc_3rd][int(offset)+int(notes_list[(index+2)%3][1])]
                                    print(f"{loc_3rd} Note: 3rd , Position: {offset} - {note_3rd}")
                                    valid = valid + 1

                                final_inversion_notes = {}
                                if valid == 3:
                                    final_inversion_notes[rootPos+strg] = note_root
                                    final_inversion_notes[pos5th+strg] = note_5th
                                    final_inversion_notes[pose3rd+strg] = note_3rd

                                    sorted_dict = {key: final_inversion_notes[key] for key in sorted(final_inversion_notes)}

                                    print(sorted_dict)
                                    noteDic[stringSets[i]].append((inversion,sorted_dict))
                                else:
                                    print("skipped an invalid iversion .... ")

                                print("-" * 80)  # Separator for readability    
        print("<>"*40)

        #print(triadType[stringSets[i]])
    print(noteDic)
    return noteDic

notes = {}
notes[triadTypes[0]] = {}
for key,note in enumerate(chromatic_notes):
    dit = runOnTriadType(triadTypes[0],note)
    notes[triadTypes[0]][note] = dit
print("ff"*200)
print(notes)

import json
def format_two_levels(data, level=0):
    """Recursively formats a dictionary to apply indentation only up to two levels deep."""
    if isinstance(data, dict) and level < 2:
        # Process the dictionary, but do not convert deeper dictionaries to JSON strings
        return {key: format_two_levels(value, level + 1) for key, value in data.items()}
    elif isinstance(data, list) and level < 2:
        # Process each item in the list individually up to two levels
        return [format_two_levels(item, level + 1) for item in data]
    else:
        # For deeper levels, return data as-is
        return data

# Pre-process the data for two-level formatting
formatted_data = format_two_levels(notes)

# Dump the data to JSON with indentation for only the first two levels
with open("two_level_dict.json", "w") as file:
    json.dump(formatted_data, file, indent=4)
